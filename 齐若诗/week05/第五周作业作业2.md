客服工作台
第二部分：BERT 文本编码与相似度计算方案 
用 BERT 的双向 Transformer 结构捕捉深层语义，解决关键词无法匹配的问题（如“退款”与“我想退钱”）。
文本编码 (Encoding)：Tokenization：将句子拆分为 Token，添加 [CLS] 标记。
向量映射：通过多层 Self-Attention 提取特征。
Pooling（池化）：取 [CLS] 位的输出或所有 Token 的均值向量作为该句的语义表示。
相似度计算：使用余弦相似度公式计算两个向量 A 与 B 的夹角余弦值。

"""

from sentence_transformers import SentenceTransformer, util
import torch

class FAQService:
    def __init__(self):
        # 加载支持中文的多语言 BERT 模型 (SBERT)
        self.model = SentenceTransformer('parphrase-multilingual-MiniLM-L12-v2')
        self.faq_data = {}      # 存储 {标准问: 答案}
        self.faq_embeddings = None
        self.standard_questions = []

    def update_knowledge_base(self, new_data):
        """同步数据库中的 FAQ 数据并向量化"""
        self.faq_data = new_data
        self.standard_questions = list(new_data.keys())
        # 离线编码：预先计算所有标准问的向量
        self.faq_embeddings = self.model.encode(self.standard_questions, convert_to_tensor=True)
        print("Successfully updated vector database.")

    def search(self, user_query, threshold=0.8):
        """实时检索最相似的问题"""
        # 1. 对用户输入进行编码
        query_embedding = self.model.encode(user_query, convert_to_tensor=True)
        
        # 2. 计算余弦相似度 (Cosine Similarity)
        cos_scores = util.cos_sim(query_embedding, self.faq_embeddings)[0]
        
        # 3. 筛选得分最高的结果
        top_score, top_idx = torch.max(cos_scores, dim=0)
        
        if top_score >= threshold:
            matched_q = self.standard_questions[top_idx]
            return {
                "answer": self.faq_data[matched_q],
                "score": float(top_score),
                "matched_question": matched_q
            }
        return {"answer": "抱歉，暂未找到匹配答案，正在为您转接人工。", "score": float(top_score)}

# --- 测试运行 ---
if __name__ == "__main__":
    service = FAQService()
    
    # 模拟从阿里云工作台录入的数据
    kb = {
        "如何修改收货地址？": "您可以在订单详情页点击'修改地址'，若已发货则无法修改。",
        "退款什么时候到账？": "退款通常在 3-5 个工作日内原路返回您的支付账户。",
        "优惠券如何使用？": "在结算页面勾选可用的优惠券即可抵扣。"
    }
    service.update_knowledge_base(kb)

    # 模拟用户提问
    query = "改一下配送地方"
    result = service.search(query)
    
    print(f"用户问: {query}")
    print(f"最匹配问题: {result.get('matched_question')}")
    print(f"匹配得分: {result['score']:.4f}")
    print(f"系统回答: {result['answer']}")